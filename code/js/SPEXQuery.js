/**
* A SPEX query object, which represents a SPARQL query (inherited from the jQuery SPARQL class, see https://github.com/jgeldart/jquery-sparql), saves user selected (bound) variables and has additionally space and time expander methods (which add corresponding optional statements).
* @class
* @property {object}  SPEXvariables  - holds the variables that the user has generated in the queryPane
* @property {object}  spatialConstraints  - holds the spatial constraints on a node in focus.
* @property {object}  temporalConstraints  - holds the temporal constraints on a node in focus.
* @property {object}  patterns  - holds SPARQL patterns (triples, subgraphs, optionals).
* @property {object}  filters  - holds SPARQL filters .
 * @property {number}  timeout  - number of seconds before timeout is thrown.
 * @property {number}  limit - maximum number of result items displayed
**/
function SPEXQuery(){ 
this.limit(50); 
this.timeout = 100000;
this.fe = new FilterExpander();
this.le = new LiteralExpander();
this.SPEXvariables = [];
this.variablelabels = [];

// redeclare patterns
    this.queryType = "SELECT";
    this.defaultGraphs = [];
    this.namedGraphs = [];
    this.variables = [];
    this.patterns = [];
    this.filters = [];
    this.combiner = "";
    this.orders = [];
    this.limitCount = -1;
    this.offsetCount = 0;
    this._prevSubj = null;
    this._prevProp = null;
    this._storedQuery = "";

}


SPEXQuery.prototype = $.sparql("http://www.example.com/sparql/");
SPEXQuery.prototype.constructor = SPEXQuery;
SPEXQuery.prototype.spatialConstraints = {};
SPEXQuery.prototype.temporalConstraints = {};
SPEXQuery.prototype.thematicConstraints = [];

/**Holds an array of variables generated by the user plus their labels as displayed in the query pane
* @function */
SPEXQuery.prototype.SPEXvariable = function(variable, label) {
    this.SPEXvariables.push(variable);
	this.variablelabels.push(label);
    return this;
  };

/** 
* gets SPARQL query expanded by optional statements for spatial, temporal and labelling literals 
@function */
SPEXQuery.prototype.getSPARQL = function (){ 	
	this.expandSpaceFilter();
	this.expandTimeFilter();	
	this.fe.expandFilterLiterals(this);
	this.le.expandLabels(this);
	return this.getPrefixedQueryString();
}
/** 
* sets a space window on some variable as a spatial constraint
* @function */
SPEXQuery.prototype.setSpatialConstraint = function(va, myWindow){
	//this.spatialConstraints.push({ "v" : va, "w" : myWindow });
	this.spatialConstraints[va] = myWindow;
}
/** 
* sets a time window on some variable as a temporal constraint
* @function */
SPEXQuery.prototype.setTemporalConstraint = function(va, time){
	//this.temporalConstraints.push({ "v" : va, "t" : time});
	this.temporalConstraints[va] = time;
}


SPEXQuery.prototype.detectWKTvars = function() {
	
	var WKTvars = [];
	/* Find the index of "geo:asWKT". */
	var latIndex, longIndex, WKTindex = null;
	for(var j = 0; j < FilterExpander.prototype.filterDataProperties.length; j++) {
		var property = FilterExpander.prototype.filterDataProperties[j];
		if(property.prop[property.prop.length - 1] === "geo:asWKT") {
			WKTindex = "_" + j + "_" + (property.prop.length - 1);
		} else if(property.prop[property.prop.length - 1] === "wgs84:lat") {
			latIndex = "_" + j + "_" + (property.prop.length - 1);
		} else if(property.prop[property.prop.length - 1] === "wgs84:long") {
			longIndex = "_" + j + "_" + (property.prop.length - 1);
		}
	}

	/* For a variable to qualify as a WKT variable it should be conected to a WKT literal and
	not be connected to both wgs84:lat and wgs84:long literals. */
	/*
	if(this.spatiallyEnabledVars) {
		for(variable in this.spatiallyEnabledVars) {
			if((this.spatiallyEnabledVars[variable].indexOf(variable + latIndex) === -1 ||
			   this.spatiallyEnabledVars[variable].indexOf(variable + longIndex) === -1) && 
			   this.spatiallyEnabledVars[variable].indexOf(variable + WKTIndex) !== -1) {
					WKTvars.push(variable);
			}
		}
	}
	*/
	console.log("SPEXQuery.prototype.detectWKTvars(): spatally enabled vars from previous query: " + JSON.stringify(spex.ex.spatiallyEnabledVars));
	if(spex.ex.spatiallyEnabledVars) {
		for(variable in spex.ex.spatiallyEnabledVars) {
			if((spex.ex.spatiallyEnabledVars[variable].indexOf(variable + latIndex) === -1 ||
			   spex.ex.spatiallyEnabledVars[variable].indexOf(variable + longIndex) === -1) && 
			   spex.ex.spatiallyEnabledVars[variable].indexOf(variable + WKTindex) !== -1) {
					WKTvars.push(variable);
			}
		}
	}
	console.log("SPEXQuery.prototype.detectWKTvars(): detected WKT vars: " + JSON.stringify(WKTvars));
	return WKTvars;
};
/** 
* Expands the query by filter statements for spatial geometries
*@function */
SPEXQuery.prototype.expandSpaceFilter = function(){
 	var WKTvars = this.detectWKTvars();

 	for (variable in this.spatialConstraints)  {

        // Check if there is really a Window object
        if (this.spatialConstraints[variable] != null && this.spatialConstraints[variable] != undefined) {
    		//if the variable is not a WKT variable
    		console.log("SPEXQuery.prototype.expandSpaceFilter(): spatial variable w/o '?': " + variable.substr(1));
    		if(WKTvars.indexOf(variable.substr(1)) === -1) { 
    			this.where(variable, "wgs84:lat", variable + "__lat")
    			.where("wgs84:long", variable + "__long");

    			this.filter("(" + variable + "__lat  < " + this.spatialConstraints[variable].upperRightLatitude + 
    				        " && " + variable + "__lat > "  + this.spatialConstraints[variable].lowerLeftLatitude + 
    			            " && " + variable + "__long < " + this.spatialConstraints[variable].upperRightLongitude + 
    			            " && " + variable + "__long > " + this.spatialConstraints[variable].lowerLeftLongitude +
                            ") || (" + variable + "__lat  < '" + this.spatialConstraints[variable].upperRightLatitude + 
                            "' && " + variable + "__lat > '"  + this.spatialConstraints[variable].lowerLeftLatitude + 
                            "' && " + variable + "__long < '" + this.spatialConstraints[variable].upperRightLongitude + 
                            "' && " + variable + "__long > '" + this.spatialConstraints[variable].lowerLeftLongitude + "')");  		
    		} else {//if it is a WKT variable
    			this.where(variable, "geo:hasGeometry", variable + "__geom")
    			.where(variable + "__geom", "geo:asWKT", variable + "__wkt");
    		}
        }
 	}
 	
 	/*
 	for (i = 0 ; i < this.spatialConstraints.length; i++)  {
		if(WKTvars.indexOf(this.spatialConstraints[i].v) === -1) { 
			this.where(this.spatialConstraints[i].v, "wgs84:lat", this.spatialConstraints[i].v + "__lat")
			.where("wgs84:long", this.spatialConstraints[i].v + "__long");

			this.filter("?lat  < " + this.spatialConstraints[i].w.upperRightLatitude + 
				        " && ?lat > "  + this.spatialConstraints[i].w.lowerLeftLatitude + 
			            " && ?long < " + this.spatialConstraints[i].w.upperRightLongitude + 
			            " && ?long > " + this.spatialConstraints[i].w.lowerLeftLongitude);  		
		} else {//if it is a WKT variable
			this.where(this.spatialConstraints[i].v, "geo:hasGeometry", this.spatialConstraints[i].v + "__geom")
			.where(this.spatialConstraints[i].v + "__geom", "geo:asWKT", this.spatialConstraints[i].v + "__wkt");
		}
 	}
 	*/

}

/** 
* Expands the query by filters for temporal information
*@function */
SPEXQuery.prototype.expandTimeFilter = function(){
 	for (variable in this.temporalConstraints)  {
		
        // Check if there is really a Time object
        if (this.temporalConstraints[variable] != null && this.temporalConstraints[variable] != undefined) {
    		var timeQuery = this.union();
    		
    		timeQuery[0].where(variable, "time:hasBeginning", variable + "INSTANT_BEGINNING")
    		.where(variable + "INSTANT_BEGINNING", "a", "time:Instant")
    		.where(variable + "INSTANT_BEGINNING", "time:inXSDDateTime", variable + "timeBeginning")
    		.where(variable, "time:hasEnd", variable + "INSTANT_END")
    		.where(variable + "INSTANT_END", "a", "time:Instant")
    		.where(variable + "INSTANT_END", "time:inXSDDateTime", variable + "timeEnd")
    		.filter(variable + "timeBeginning  >= '" + this.temporalConstraints[variable].timeBeginning + "'^^xsd:dateTime && " + variable + "timeEnd <= '"  + this.temporalConstraints[variable].timeEnd + "'^^xsd:dateTime");
    		
    		timeQuery[1].where(variable, variable + "timelink", variable + "link")
    		.where(variable + "link", "xsd:gYear", variable + "year")
    		.filter(variable + "year >= '" + this.temporalConstraints[variable].timeBeginning.slice(0,4) + "' && " + variable + "year <= '"  + this.temporalConstraints[variable].timeEnd.slice(0,4) + "'");
        }
 	}
 	/*
 	for (i=0;i<this.temporalConstraints.length;i++)  {
		
		this.where(this.temporalConstraints[i].v, "time:hasBeginning", "?INSTANT_BEGINNING");
		this.where("?INSTANT_BEGINNING", "a", "time:Instant"); 
		this.where("?INSTANT_BEGINNING", "time:inXSDDateTime", "?timeBeginning");

		this.where(this.temporalConstraints[i].v, "time:hasEnd", "?INSTANT_END");
		this.where("?INSTANT_END", "a", "time:Instant"); 
		this.where("?INSTANT_END", "time:inXSDDateTime", "?timeEnd");

		this.filter("?timeBeginning  >= '" + this.temporalConstraints[i].t.timeBeginning + "'^^xsd:dateTime && ?timeEnd <= '"  + this.temporalConstraints[i].t.timeEnd + "'^^xsd:dateTime");  		

 	}
 	*/
	
}

/**
* Returns the query as a string with prefixes
*@function */
SPEXQuery.prototype.getPrefixedQueryString = function(){
	var prefixList = [];
	var string = this.serialiseQuery();
	
	//Find prefixes in the querystring
	var newString = string;	
	var j = newString.indexOf(":");
	while(j != -1){
		for (var i=j-1; i>=0; i--){
			var char=newString.charAt(i);
			if(char == '<') i = -1;
			else if([' ','|','{','\n','}','.','>','^','/','!','(','\t'].indexOf(char) != -1){
				var pfx = newString.substring(i+1,j);
				//compare prefix with prefixlist. If found, add to prefixes of query
				for(var k=0; k<prefixes.length; k++){
					if(prefixes[k].prefix == pfx){
						k = prefixes.length;
						prefixList.push(pfx);
					}
				}				
				i = -1;
			}
		}
		newString = newString.substring(j+1);
		j = newString.indexOf(":");
	}
	
	//Replace uri's enclosed in '<' and '>' with the corresponding prefix
	newString = string;
	var stringChanged = false;
	do{
		stringChanged = false;
		//Find the string enclosed in '<' and '>'
		var i = string.indexOf("<");
		if(i != -1){
			var j = string.substring(i).indexOf(">") + i;
			if(j != -1){
				var theUri = string.substring(i+1,j);
				//Replace this string with the correct prefix from the prefixlist, and add to query prefixes
				if(theUri.indexOf(" ") == -1){
					for(var k=0; k<prefixes.length; k++){
						if(theUri.indexOf(prefixes[k].uri) != -1){
							newString = string.substring(0,i) + theUri.replace(prefixes[k].uri, prefixes[k].prefix + ':') + string.substring(j+1);
							prefixList.push(prefixes[k].prefix);
							k = prefixes.length;
							stringChanged = true;
						}
					}
				}
			}
		}
		string = newString;
	} while (stringChanged == true);
	
	//store the query in 'string'
	string = newString;
	
	//remove duplicates from prefixList
	prefixList.sort();
	for(var i=0; i< prefixList.length;i++){
		if(prefixList[i]==prefixList[i+1]){
			prefixList.splice(i+1,1);
			i--;
		}
	}
	
	var queryString = "";
	
	//Add prefixes to 'queryString', using 'prefixList' and master prefix list 'prefixes' 
	for(var i=0;i<prefixList.length;i++){
		for(var j=0;j<prefixes.length;j++){
			var pfx=prefixes[j];
			if(prefixList[i] == pfx.prefix){
				queryString += "PREFIX " + pfx.prefix + ": <" + pfx.uri + ">\n";
				j=prefixes.length;
			} else if(j==prefixes.length - 1){
				console.log("The prefix " + prefixList[i] + " was not found in the stored prefixes!");
			}
		}
	}
	
	//Add the actual query 'string' to 'queryString'
	
	queryString+=string;
	
	return queryString;
};

