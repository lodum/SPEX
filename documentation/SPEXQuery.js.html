<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SPEXQuery.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: SPEXQuery.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* A SPEX query object, which represents a SPARQL query (inherited from the jQuery SPARQL class, see https://github.com/jgeldart/jquery-sparql), saves user selected (bound) variables and has additionally space and time expander methods (which add corresponding optional statements).
* @class
* @property {object}  SPEXvariables  - holds the variables that the user has generated in the queryPane
* @property {object}  spatialConstraints  - holds the spatial constraints on a node in focus.
* @property {object}  temporalConstraints  - holds the temporal constraints on a node in focus.
* @property {object}  patterns  - holds SPARQL patterns (triples, subgraphs, optionals).
* @property {object}  filters  - holds SPARQL filters .
* @property {object}  prefixes  - holds the list of SPEX prefixes.
 * @property {number}  timeout  - number of seconds before timeout is thrown.
 * @property {number}  limit - maximum number of result items displayed
**/
function SPEXQuery(){ 
this.limit(50); 
this.timeout = 100000;
this.fe = new FilterExpander();
this.le = new LiteralExpander();
this.SPEXvariables = [];
this.variablelabels = [];

// redeclare patterns
    this.queryType = "SELECT";
    this.prefixes = SPEXPrefixes;
    this.defaultGraphs = [];
    this.namedGraphs = [];
    this.variables = [];
    this.patterns = [];
    this.filters = [];
    this.combiner = "";
    this.orders = [];
    this.limitCount = -1;
    this.offsetCount = 0;
    this._prevSubj = null;
    this._prevProp = null;
    this._storedQuery = "";

}


SPEXQuery.prototype = $.sparql("http://www.example.com/sparql/");
SPEXQuery.prototype.constructor = SPEXQuery;
SPEXQuery.prototype.spatialConstraints = {};
SPEXQuery.prototype.temporalConstraints = {};
SPEXQuery.prototype.thematicConstraints = [];

/**Holds an array of variables generated by the user plus their labels as displayed in the query pane
* @function */
SPEXQuery.prototype.SPEXvariable = function(variable, label) {
    this.SPEXvariables.push(variable);
	this.variablelabels.push(label);
    return this;
  };

/** 
* gets SPARQL query expanded by optional statements for spatial, temporal and labelling literals 
@function */
SPEXQuery.prototype.getSPARQL = function (){ 	
	this.expandSpaceFilter();
	this.expandTimeFilter();	
	this.fe.expandFilterLiterals(this);
	this.le.expandLabels(this);
	return this.serialiseQuery();
}
/** 
* sets a space window on some variable as a spatial constraint
* @function */
SPEXQuery.prototype.setSpatialConstraint = function(va, myWindow){
	//this.spatialConstraints.push({ "v" : va, "w" : myWindow });
	this.spatialConstraints[va] = myWindow;
}
/** 
* sets a time window on some variable as a temporal constraint
* @function */
SPEXQuery.prototype.setTemporalConstraint = function(va, time){
	//this.temporalConstraints.push({ "v" : va, "t" : time});
	this.temporalConstraints[va] = time;
}


SPEXQuery.prototype.detectWKTvars = function() {
	
	var WKTvars = [];
	/* Find the index of "geo:asWKT". */
	var latIndex, longIndex, WKTindex = null;
	for(var j = 0; j &lt; FilterExpander.prototype.filterDataProperties.length; j++) {
		var property = FilterExpander.prototype.filterDataProperties[j];
		if(property.prop[property.prop.length - 1] === "geo:asWKT") {
			WKTindex = "_" + j + "_" + (property.prop.length - 1);
		} else if(property.prop[property.prop.length - 1] === "wgs84:lat") {
			latIndex = "_" + j + "_" + (property.prop.length - 1);
		} else if(property.prop[property.prop.length - 1] === "wgs84:long") {
			longIndex = "_" + j + "_" + (property.prop.length - 1);
		}
	}

	/* For a variable to qualify as a WKT variable it should be conected to a WKT literal and
	not be connected to both wgs84:lat and wgs84:long literals. */
	/*
	if(this.spatiallyEnabledVars) {
		for(variable in this.spatiallyEnabledVars) {
			if((this.spatiallyEnabledVars[variable].indexOf(variable + latIndex) === -1 ||
			   this.spatiallyEnabledVars[variable].indexOf(variable + longIndex) === -1) &amp;&amp; 
			   this.spatiallyEnabledVars[variable].indexOf(variable + WKTIndex) !== -1) {
					WKTvars.push(variable);
			}
		}
	}
	*/
	console.log("SPEXQuery.prototype.detectWKTvars(): spatally enabled vars from previous query: " + JSON.stringify(spex.ex.spatiallyEnabledVars));
	if(spex.ex.spatiallyEnabledVars) {
		for(variable in spex.ex.spatiallyEnabledVars) {
			if((spex.ex.spatiallyEnabledVars[variable].indexOf(variable + latIndex) === -1 ||
			   spex.ex.spatiallyEnabledVars[variable].indexOf(variable + longIndex) === -1) &amp;&amp; 
			   spex.ex.spatiallyEnabledVars[variable].indexOf(variable + WKTindex) !== -1) {
					WKTvars.push(variable);
			}
		}
	}
	console.log("SPEXQuery.prototype.detectWKTvars(): detected WKT vars: " + JSON.stringify(WKTvars));
	return WKTvars;
};
/** 
* Expands the query by filter and optional statements which catch spatial geometries
*@function */
SPEXQuery.prototype.expandSpaceFilter = function(){
 	var WKTvars = this.detectWKTvars();

 	for (variable in this.spatialConstraints)  {

        // Check if there is really a Window object
        if (this.spatialConstraints[variable] != null &amp;&amp; this.spatialConstraints[variable] != undefined) {
    		//if the variable is not a WKT variable
    		console.log("SPEXQuery.prototype.expandSpaceFilter(): spatial variable w/o '?': " + variable.substr(1));
    		if(WKTvars.indexOf(variable.substr(1)) === -1) { 
    			this.where(variable, "wgs84:lat", variable + "__lat")
    			.where("wgs84:long", variable + "__long");

    			this.filter("(" + variable + "__lat  &lt; " + this.spatialConstraints[variable].upperRightLatitude + 
    				        " &amp;&amp; " + variable + "__lat > "  + this.spatialConstraints[variable].lowerLeftLatitude + 
    			            " &amp;&amp; " + variable + "__long &lt; " + this.spatialConstraints[variable].upperRightLongitude + 
    			            " &amp;&amp; " + variable + "__long > " + this.spatialConstraints[variable].lowerLeftLongitude +
                            ") || (" + variable + "__lat  &lt; '" + this.spatialConstraints[variable].upperRightLatitude + 
                            "' &amp;&amp; " + variable + "__lat > '"  + this.spatialConstraints[variable].lowerLeftLatitude + 
                            "' &amp;&amp; " + variable + "__long &lt; '" + this.spatialConstraints[variable].upperRightLongitude + 
                            "' &amp;&amp; " + variable + "__long > '" + this.spatialConstraints[variable].lowerLeftLongitude + "')");  		
    		} else {//if it is a WKT variable
    			this.where(variable, "geo:hasGeometry", variable + "__geom")
    			.where(variable + "__geom", "geo:asWKT", variable + "__wkt");
    		}
        }
 	}
 	
 	/*
 	for (i = 0 ; i &lt; this.spatialConstraints.length; i++)  {
		if(WKTvars.indexOf(this.spatialConstraints[i].v) === -1) { 
			this.where(this.spatialConstraints[i].v, "wgs84:lat", this.spatialConstraints[i].v + "__lat")
			.where("wgs84:long", this.spatialConstraints[i].v + "__long");

			this.filter("?lat  &lt; " + this.spatialConstraints[i].w.upperRightLatitude + 
				        " &amp;&amp; ?lat > "  + this.spatialConstraints[i].w.lowerLeftLatitude + 
			            " &amp;&amp; ?long &lt; " + this.spatialConstraints[i].w.upperRightLongitude + 
			            " &amp;&amp; ?long > " + this.spatialConstraints[i].w.lowerLeftLongitude);  		
		} else {//if it is a WKT variable
			this.where(this.spatialConstraints[i].v, "geo:hasGeometry", this.spatialConstraints[i].v + "__geom")
			.where(this.spatialConstraints[i].v + "__geom", "geo:asWKT", this.spatialConstraints[i].v + "__wkt");
		}
 	}
 	*/

}

/** 
* Expands the query by optional statements and filters which catch temporal information
*@function */
SPEXQuery.prototype.expandTimeFilter = function(){
 	for (variable in this.temporalConstraints)  {
		
        // Check if there is really a Time object
        if (this.temporalConstraints[variable] != null &amp;&amp; this.temporalConstraints[variable] != undefined) {
    		var timeQuery = this.union();
    		
    		timeQuery[0].where(variable, "time:hasBeginning", variable + "INSTANT_BEGINNING")
    		.where(variable + "INSTANT_BEGINNING", "a", "time:Instant")
    		.where(variable + "INSTANT_BEGINNING", "time:inXSDDateTime", variable + "timeBeginning")
    		.where(variable, "time:hasEnd", variable + "INSTANT_END")
    		.where(variable + "INSTANT_END", "a", "time:Instant")
    		.where(variable + "INSTANT_END", "time:inXSDDateTime", variable + "timeEnd")
    		.filter(variable + "timeBeginning  >= '" + this.temporalConstraints[variable].timeBeginning + "'^^xsd:dateTime &amp;&amp; " + variable + "timeEnd &lt;= '"  + this.temporalConstraints[variable].timeEnd + "'^^xsd:dateTime");
    		
    		timeQuery[1].where(variable, variable + "timelink", variable + "link")
    		.where(variable + "link", "xsd:gYear", variable + "year")
    		.filter(variable + "year >= '" + this.temporalConstraints[variable].timeBeginning.slice(0,4) + "' &amp;&amp; " + variable + "year &lt;= '"  + this.temporalConstraints[variable].timeEnd.slice(0,4) + "'");
        }
 	}
 	/*
 	for (i=0;i&lt;this.temporalConstraints.length;i++)  {
		
		this.where(this.temporalConstraints[i].v, "time:hasBeginning", "?INSTANT_BEGINNING");
		this.where("?INSTANT_BEGINNING", "a", "time:Instant"); 
		this.where("?INSTANT_BEGINNING", "time:inXSDDateTime", "?timeBeginning");

		this.where(this.temporalConstraints[i].v, "time:hasEnd", "?INSTANT_END");
		this.where("?INSTANT_END", "a", "time:Instant"); 
		this.where("?INSTANT_END", "time:inXSDDateTime", "?timeEnd");

		this.filter("?timeBeginning  >= '" + this.temporalConstraints[i].t.timeBeginning + "'^^xsd:dateTime &amp;&amp; ?timeEnd &lt;= '"  + this.temporalConstraints[i].t.timeEnd + "'^^xsd:dateTime");  		

 	}
 	*/
	
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="FilterExpander.html">FilterExpander</a></li><li><a href="FilterResults.html">FilterResults</a></li><li><a href="LabelGenerator.html">LabelGenerator</a></li><li><a href="LiteralExpander.html">LiteralExpander</a></li><li><a href="QueryExecutor.html">QueryExecutor</a></li><li><a href="queryPane.html">queryPane</a></li><li><a href="ResultsPane.html">ResultsPane</a></li><li><a href="slider.html">slider</a></li><li><a href="SpaceFilterPane.html">SpaceFilterPane</a></li><li><a href="spex.html">spex</a></li><li><a href="SPEXQuery.html">SPEXQuery</a></li><li><a href="SPEXResultSet.html">SPEXResultSet</a></li><li><a href="Suggester.html">Suggester</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Tue Sep 23 2014 16:52:30 GMT+0200 (MESZ)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
